> 此为学习笔记，参考的教程链接为[https://www.bilibili.com/video/BV1et411b73Z?p=84](https://www.bilibili.com/video/BV1et411b73Z?p=84)
## 1. 内存分区
- 代码区
	- 共享、只读
- 全局区：全局变量、静态变量（static）、常量（字符串、const修饰的全局常量）
- 栈区：编译器自动分配释放，如函数参数值、局部变量
	- 不要返回局部变量的地址，栈区数据在函数执行后自动释放
- 堆区：程序员分配释放，程序结束时系统也会回收
	- 用new在堆区开辟内存：`int* p = new int(10);`
	- 释放：`delete p;`, `delete[] arr;`

## 2. 引用
给变量起别名：数据类型 &别名 = 原名，`int &b = a;`
- 引用必须初始化，且之后不能更改
- 引用传递，可以用形参修饰实参，即可以不用指针的地址传递
	- func(int& a, int& b){}, 调用时func(a, b)
- 引用作为函数返回值
	- 不要返回局部变量的引用
	- 函数的调用可以作为左值
```cpp
int& aka() {
	static int a = 10;
	return a;}
int main() {
	int &ref = aka();
	aka() = 1000; //赋值操作，于是ref2 = 1000;
}
```
- 引用的本质是一个指针常量
	-  `int& ref1 = a`等价于`int* const ref1 = &a;`
	-  `ref1 = 20;`，内部发现ref1是引用后，等价于`*ref1 = 20;`
- 常量引用：const用来修饰形参，防止误操作，`func(const int& a)`

## 3. 函数提高
- 形参可以有默认值
	- 如果某个位置有默认值了，其后的所有形参都必须有默认值
	- 函数声明和实现只能有一个有默认参数
- 占位参数：函数中只写数据类型，在调用时必须补上，`int fun(int a,int)`, `int func(int a,int =10)`
- 函数重载：同一个作用域下，函数名相同， 函数参数类型不同或者个数不同或者顺序不同
	- 引用作为重载条件时：int& a和const int& a；当传入的是变量时调前者，常量调后者。
	- 函数重载碰到默认参数：产生歧义，报错

## 4. 类和对象
面向对象：封装、继承、多态
### 4.1 封装
#### 定义
- 类中的属性和行为统称为成员
	- 属性：成员属性、成员变量
	- 行为：成员函数、成员方法
- 实例化对象
- 访问权限：
	- public公共：成员类内可以访问，类外可以访问
	- protected保护：成员类内可以访问，类外不可以访问，子类可以访问
	- private私有：成员类内可以访问，类外不可以访问，子类不可以访问
#### 注意事项
- struct和class的区别：struct默认权限是public，class默认权限是private
- 成员属性设置为private：可以自己控制读写权限、对于写权限可以检测数据的有效性
### 4.2 对象特性
#### 构造函数和析构函数
- 构造函数：创建对象时为对象的成员属性赋值，由编译器自动调用，无须手动
	- 类名() {}，可以有参数，可重载
	- 无参构造、有参构造、拷贝构造
		- 调用默认（无参）构造函数时，不要加()，否则会认为是函数声明
		- 值传递时会调用拷贝构造，值方式返回局部对象时也会调用拷贝构造
	- 默认情况，c++至少给一个类添加默认构造函数（无参）、默认析构函数（无参）、默认拷贝构造函数
		- 若用户定义有参构造，则c++不再提供默认无参构造，但会提供默认拷贝构造
		- 若用户定义拷贝构造，则c++不再提供其他构造函数
- 析构函数：对象销毁前系统自动调用，执行一些清理工作
	- ~类名() {}，不可以有参数，不能重载
#### 其他
1. 深拷贝与浅拷贝
- 浅拷贝：简单的赋值拷贝
	- 可能产生的问题：堆区的内存重复释放
- 深拷贝：在堆区重新申请空间，进行拷贝
- So，如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题
2. 初始化列表
初始化列表初始化属性：`Student(int a, int b) :m_a(a), m_b(b) {}`
3. 类对象作为类成员
-  当其他类对象作为本类成员，构造时先构造其他类，再自身；析构与构造相反
4. 静态成员
