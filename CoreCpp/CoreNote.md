## 1. 内存分区
- 代码区
	- 共享、只读
- 全局区：全局变量、静态变量（static）、常量（字符串、const修饰的全局常量）
- 栈区：编译器自动分配释放，如函数参数值、局部变量
	- 不要返回局部变量的地址，栈区数据在函数执行后自动释放
- 堆区：程序员分配释放，程序结束时系统也会回收
	- 用new在堆区开辟内存：`int* p = new int(10);`
	- 释放：`delete p;`, `delete[] arr;`

## 2. 引用
给变量起别名：数据类型 &别名 = 原名，`int &b = a;`
- 引用必须初始化，且之后不能更改
- 引用传递，可以用形参修饰实参，即可以不用指针的地址传递
	- func(int& a, int& b){}, 调用时func(a, b)
- 引用作为函数返回值
	- 不要返回局部变量的引用
	- 函数的调用可以作为左值
```cpp
int& aka() {
	static int a = 10;
	return a;}
int main() {
	int &ref = aka();
	aka() = 1000; //赋值操作，于是ref2 = 1000;
}
```
- 引用的本质是一个指针常量
	-  `int& ref1 = a`等价于`int* const ref1 = &a;`
	-  `ref1 = 20;`，内部发现ref1是引用后，等价于`*ref1 = 20;`
- 常量引用：const用来修饰形参，防止误操作，`func(const int& a)`

## 3. 函数提高
- 形参可以有默认值
	- 如果某个位置有默认值了，其后的所有形参都必须有默认值
	- 函数声明和实现只能有一个有默认参数
- 占位参数：函数中只写数据类型，在调用时必须补上，`int fun(int a,int)`, `int func(int a,int =10)`
- 函数重载：同一个作用域下，函数名相同， 函数参数类型不同或者个数不同或者顺序不同
	- 引用作为重载条件时：int& a和const int& a；当传入的是变量时调前者，常量调后者。
	- 函数重载碰到默认参数：产生歧义，报错

## 4. 类和对象
